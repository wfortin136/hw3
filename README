HW4 - 51087: HPC
Billy Fortin
March 9, 2015

Files Included:
1) Makefile
2) atomic_hw4.f95
3) serial_hw4.f95
4) tpriv_hw4.f95
5) create_image
6) G_900000_500X500.out
7) Readme
8) Part 3 Graphical Analysis.xlsx
9) runscript.sbatch
10) Circular Image.png

Description of Files
The files above are associated with the problem sections as followed:
Part 1: serial_hw4.f95
Part 2: a) atomic_hw4.f95
	b) tpriv_hw4.f95
Part 3: runscript.sbatch; Part 3 Graphical Analysis.xlsx
Part 4: create_image; G_900000_500X500.out; Circular Image.png

Instructions
Use the Makefile to compile all the source code
   
   make

To run on midway, run the batch script from home directory
  
   batch runscript.sbatch

Output will be in a file called ""hw4_analysis.out as specificed in the batch script.

To run independently, use the following commands

   ./serial 500000 250
   ./atomic 500000 250
   ./tpriv 500000 250

Where the first number is the number of rays and the second is the gridsize
for the viewing window.

In order to plot the data, run the following

   gnuplot create_image

Part 3 Write-up
The atomic version of the OpenMP code performs slightly better than the thread
thread private. For the Threadprivate version, I used the reduction clause
in order to keep a private copy of each G value. This is stated in the OpenMP
Manual as follows:
"A private copy of each list item is created, one for each implicit task, as 
if the private clause had been used." 
and
"... the original list item is updated by combining its original value with 
the final value of each of the private copies, using the operator specified."

Therefore, there inherent overhead associated with using the Reduction clause
because OpenMP must store the private copy, then accumulate all the private
copies to a single value. Where as with the atomic version, there is only
elemental locking at the specified memory location. And the likilhood of
accessing the same memory location at the same time is quite low in our example,
especially as we increase our number of grids. Therefore, any bottlenecking due
to the atomic statement is probably minimal, and less than the overhead from
the reduction clause. However, if we had a large number of read/write conflicts,
this may not be the case and using thread private may produce a more efficiect
solution.

